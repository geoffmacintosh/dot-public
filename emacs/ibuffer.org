#+title: IBuffer
#+property: header-args :results output silent :comments link :noweb yes

* Ibuffer
#+begin_src emacs-lisp
  (use-package ibuffer
    :straight nil
    :config
    (defalias 'list-buffers 'ibuffer
      "Use ibuffer instead of list-buffers")
    :custom
    (ibuffer-expert t)
    <<filter-groups>>
    :hook
    (ibuffer-mode . actuator-ibuffer-setup))
#+end_src

#+name: filter-groups
#+begin_src emacs-lisp
  (ibuffer-show-empty-filter-groups nil)
  (ibuffer-saved-filter-groups
   '(("home"
      ("Magit"     (name . "magit"))
      ("Help"  (or (name . "\*Help\*")
                   (name . "\*Apropos\*")
                   (name . "\*info\*")))
      ("Src"       (name . "\*Org Src"))
      ("Dired"     (mode . "Dired by name"))
      ("Misc"      (name . "^\\*.*\\*$")))))
#+end_src

#+begin_src emacs-lisp
  (defun actuator-ibuffer-setup ()
    "Setup ibuffer defaults."
    (require 'ibuf-ext)
    (ibuffer-auto-mode 1)
    (ibuffer-switch-to-saved-filter-groups "home")
    (toggle-truncate-lines +1))
#+end_src

#+results: setup-ibuffer
: actuator-ibuffer-setup

* Ibuffer

#+begin_src emacs-lisp
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ((> (buffer-size) 100000) (format "%7.0fk" (/ (buffer-size) 1000.0)))
     ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     (t (format "%8d" (buffer-size)))))


    (setq ibuffer-formats
          '((mark modified read-only " "
                  (name 18 18 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  filename-and-process)))

  (defun ajv/human-readable-file-sizes-to-bytes (string)
    "Convert a human-readable file size into bytes."
    (interactive)
    (cond
     ((string-suffix-p "G" string t)
      (* 1000000000 (string-to-number (substring string 0 (- (length string) 1)))))
     ((string-suffix-p "M" string t)
      (* 1000000 (string-to-number (substring string 0 (- (length string) 1)))))
     ((string-suffix-p "K" string t)
      (* 1000 (string-to-number (substring string 0 (- (length string) 1)))))
     (t
      (string-to-number (substring string 0 (- (length string) 1))))
     )
    )

  (defun ajv/bytes-to-human-readable-file-sizes (bytes)
    "Convert number of bytes to human-readable file size."
    (interactive)
    (cond
     ((> bytes 1000000000) (format "%10.1fG" (/ bytes 1000000000.0)))
     ((> bytes 100000000) (format "%10.0fM" (/ bytes 1000000.0)))
     ((> bytes 1000000) (format "%10.1fM" (/ bytes 1000000.0)))
     ((> bytes 100000) (format "%10.0fk" (/ bytes 1000.0)))
     ((> bytes 1000) (format "%10.1fk" (/ bytes 1000.0)))
     (t (format "%10d" bytes)))
    )


  (define-ibuffer-column size-h
    (:name "Size"
           :inline t
           :summarizer
           (lambda (column-strings)
             (let ((total 0))
               (dolist (string column-strings)
                 (setq total

                       (+ (float (ajv/human-readable-file-sizes-to-bytes string))
                          total)))
               (ajv/bytes-to-human-readable-file-sizes total)))
           )
    (ajv/bytes-to-human-readable-file-sizes (buffer-size)))


  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 20 20 :left :elide)
                " "
                (size-h 11 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))

#+end_src

#+results:
| mark | modified | read-only    | locked |          | (name 20 20 :left :elide) |   | (size-h 11 -1 :right) |   | (mode 16 16 :left :elide) |   | filename-and-process |
| mark |          | (name 16 -1) |        | filename |                           |   |                       |   |                           |   |                      |

#+begin_src emacs-lisp
  (setq mp/ibuffer-collapsed-groups (list "Helm" "*Internal*"))

  (defadvice ibuffer (after collapse-helm)
    (dolist (group mp/ibuffer-collapsed-groups)
            (progn
              (goto-char 1)
              (when (search-forward (concat "[ " group " ]") (point-max) t)
                (progn
                  (move-beginning-of-line nil)
                  (ibuffer-toggle-filter-group)
                  )
                )
              )
            )
      (goto-char 1)
      (search-forward "[ " (point-max) t)
    )

  (ad-activate 'ibuffer)
#+end_src

#+begin_src emacs-lisp
    (defun ibuffer-previous-line ()
      (interactive) (previous-line)
      (if (<= (line-number-at-pos) 2)
          (goto-line (- (count-lines (point-min) (point-max)) 2))))
    (defun ibuffer-next-line ()
      (interactive) (next-line)
      (if (>= (line-number-at-pos) (- (count-lines (point-min) (point-max)) 1))
          (goto-line 3)))
    (define-key ibuffer-mode-map (kbd "<up>") 'ibuffer-previous-line)
    (define-key ibuffer-mode-map (kbd "<down>") 'ibuffer-next-line)


    (defun ibuffer-advance-motion (direction)
          (forward-line direction)
          (beginning-of-line)
          (if (not (get-text-property (point) 'ibuffer-filter-group-name))
              t
            (ibuffer-skip-properties '(ibuffer-filter-group-name)
                                     direction)
            nil))
    (defun ibuffer-previous-line (&optional arg)
      "Move backwards ARG lines, wrapping around the list if necessary."
      (interactive "P")
      (or arg (setq arg 1))
      (let (err1 err2)
        (while (> arg 0)
          (cl-decf arg)
          (setq err1 (ibuffer-advance-motion -1)
                err2 (if (not (get-text-property (point) 'ibuffer-title))
                         t
                       (goto-char (point-max))
                       (beginning-of-line)
                       (ibuffer-skip-properties '(ibuffer-summary
                                                  ibuffer-filter-group-name)
                                                -1)
                       nil)))
        (and err1 err2)))
    (defun ibuffer-next-line (&optional arg)
      "Move forward ARG lines, wrapping around the list if necessary."
      (interactive "P")
      (or arg (setq arg 1))
      (let (err1 err2)
        (while (> arg 0)
          (cl-decf arg)
          (setq err1 (ibuffer-advance-motion 1)
                err2 (if (not (get-text-property (point) 'ibuffer-summary))
                         t
                       (goto-char (point-min))
                       (beginning-of-line)
                       (ibuffer-skip-properties '(ibuffer-summary
                                                  ibuffer-filter-group-name
                                                  ibuffer-title)
                                                1)
                       nil)))
        (and err1 err2)))
    (defun brust/ibuffer-next-header ()
      (interactive)
      (while (ibuffer-next-line)))
    (defun brust/ibuffer-previous-header ()
      (interactive)
      (while (ibuffer-previous-line)))
    (define-key ibuffer-mode-map (kbd "<up>") 'ibuffer-previous-line)
    (define-key ibuffer-mode-map (kbd "<down>") 'ibuffer-next-line)
    (define-key ibuffer-mode-map (kbd "<right>") 'ibuffer-previous-header)
    (define-key ibuffer-mode-map (kbd "<left>") 'ibuffer-next-header)
#+end_src

#+results:
: ibuffer-next-header
