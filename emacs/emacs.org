#+title: Emacs
#+property: header-args :results output silent :comments link

* Initialization

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
#+end_src

#+begin_src emacs-lisp
  (use-package no-littering)
  (use-package bind-key)
  (use-package exec-path-from-shell)
#+end_src

#+begin_src emacs-lisp
  (use-package system-packages
    :custom
    (system-packages-use-sudo nil)
    (system-packages-package-manager 'nix))
  (use-package use-package-ensure-system-package)
#+end_src

* User Interface

#+begin_src emacs-lisp
  (use-package help
    :straight nil
    :custom
    (help-window-select t))
#+end_src

#+begin_src emacs-lisp
  (use-package jit-lock
    :straight nil
    :custom
    (jit-lock-defer-time 0))
#+end_src

#+begin_src emacs-lisp
  (blink-cursor-mode -1)
  (setq cursor-type 'box)
#+end_src

#+begin_src emacs-lisp
  (setq scroll-conservatively 101)
  (setq scroll-margin 0)
  (setq mouse-wheel-scroll-amount '(1))
#+end_src

#+begin_src emacs-lisp
  (defun display-startup-echo-area-message ()
    "Remove the GNU info from the minibuffer on startup"
    (message ""))
  (setq inhibit-startup-message t)
#+end_src

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

When running in a non-client-server-mode, per-frame settings only need to be set once because frames aren't really created, even if they are. It's complicated. Anyway, frame-based features need to be initialized every time ~emacsclient~ is called, so I'm going to use a custom function for convenience. It takes one argument, which is the frame that it's being called after. It isn't used, and so is provided optionally.

This function checks to see if ~tool-bar-mode~ etc are non-nil, then sets it to nil. That way, if emacs is opened in a terminal and things like ~tool-bar-mode~ aren't relevent, they're not set. Howevew, I like ~menu-bar-mode~ in the GUI but not in the terminal, so I disable it in non-gui-mode.

#+begin_src emacs-lisp
  (defun actuator-font-exists-p (font)
    "Returns non-nil if the font is loaded."
    (member font (font-family-list)))
#+end_src

#+begin_src emacs-lisp
  (defun actuator-frame-init (&optional _frame)
    "Initialize per-frame variables"
    (when (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    (when (fboundp 'tooltip-mode)    (tooltip-mode    -1))
    (when (and (not (display-graphic-p))
	       (fboundp 'menu-bar-mode))
      (menu-bar-mode   -1))
    (when (actuator-font-exists-p "SF Mono")
      (set-frame-font "SF Mono-14" nil t)))
#+end_src

Then I need to have it run after emacsclient is run. There's a special hook for that, but it's non-standard, so passes a single argument, which is the frame it's being called on, but apparently it's not super important to do anything with it. Oh well.

#+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions 'actuator-frame-init)
#+end_src

Then I run the function a normal initialization so that the GUI settings are correct.

#+begin_src emacs-lisp
  (actuator-frame-init)
#+end_src

** Theme
#+begin_src emacs-lisp
  (load-theme 'actuator t)
#+end_src


** Scratch Message
#+begin_src emacs-lisp
  (setq initial-scratch-message "")
#+end_src

* Core Adjustments
** Settings

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq revert-without-query t)
  (setq auto-revert-check-vc-info t)

  (delete-selection-mode t)
  (midnight-mode 1)
  (setq sentence-end-double-space nil)

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  (add-hook 'before-save-hook 'whitespace-cleanup)

  (setq indent-tabs-mode nil)
  (setq require-final-newline t)

  (save-place-mode 1)

  (setq backup-by-copying    t)
  (setq delete-old-versions  t)
  (setq kept-new-versions    50)
  (setq kept-old-versions    5)
  (setq version-control      t)

  (setq vc-make-backup-files t)

  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-ignore-buffers-re "^\\*")
  (setq uniquify-strip-common-suffix nil)
#+end_src

** Recent Files

Recentf mode builds a list of recently opened files that are automatically saved across sessions.

#+begin_src emacs-lisp
  (use-package recentf
    :after no-littering
    :straight nil
    :config
    (recentf-mode)
    :custom
    (recentf-max-saved-items 500)
    (recentf-exclude `(,no-littering-var-directory
		       ,no-littering-etc-directory))
    :hook (midnight . recentf-cleanup))
#+end_src

** Autosaves
Autosaves are those things that are done every 300 characters in case Emacs crashes. They might as well also be saved in a nice place. I'm not positive what the "auto-save-file-name-transforms" does, but I think it helps with ensuring that files are correctly named in the saves folders.

#+begin_src emacs-lisp
  (use-package emacs
    :straight nil
    :after no-littering
    :custom
    (auto-save-file-name-transforms
     `((".*" ,(expand-file-name "auto-save/" no-littering-var-directory) t)))
    (auto-save-mode))
#+end_src

** Move Customize Settings File

If I use ~M-x customize~, it normally garbages up my init.el file. This allows it to garbage up its own place. Because [[https://github.com/nonissue][some nerd]] complained about not being able to clone and use my config without errors, I added a check to see if the file =~/.emacs.d/custom.el= exists. If it doesn't, it's created automatically and then used. If you want to use the customize interface, this is probably a bad thing to use, I think.

#+begin_src emacs-lisp
  (use-package cus-edit
    :straight nil
    :after no-littering
    :custom
    (custom-file (expand-file-name "custom.el" no-littering-var-directory))
    :config
    (load custom-file 'noerror))
#+end_src

* Core Modules
** Magit
   :PROPERTIES:
   :ID:       1539207a-2931-4f38-aa1c-b1464abd9cae
   :END:
 According to the Magit documentation, most Magit stuff is done from the status window, so creating a binding for that is a good idea.

 The config section also initializes the package [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]], which is an "...Emacs library to ensure environment variables inside Emacs look the same as in the user's shell." I use it to fix an issue with Magit not being able to find ~git-lfs~. It would fail trying to push to GitHub because of that. [[https://magit.vc/manual/magit/I-am-using-OS-X-and-SOMETHING-works-in-shell-but-not-in-Magit.html#I-am-using-OS-X-and-SOMETHING-works-in-shell-but-not-in-Magit][Magit]] has documentation on the subject. Anyway, it's not a package that is useful elsewhere (so far), so I'm only loading it when Magit is loaded. Let's see it that works. The only way to tell is to push somthing to the server. Sweet. FYI, it worked.

 #+begin_src emacs-lisp
   (use-package magit
     :after exec-path-from-shell
     :bind ("C-c g" . magit-status)
     :custom
     (magit-diff-refine-hunk 'all)
     (magit-save-repository-buffers 'dontask)
     ;; (magit-section-initial-visibility-alist
     ;;  '((untracked . show)
     ;;    (unstaged  . show)
     ;;    (upushed   . show)
     ;;    (unpulled  . show)
     ;;    (stashes   . show)
     ;;    (recent    . show)))
     (magit-push-always-verify nil)
     (magit-revert-buffers 'silent)
     (magit-no-confirm '(stage-all-changes
			 unstage-all-changes))
     :config
     (defadvice magit-status (around magit-fullscreen activate)
       (window-configuration-to-register :magit-fullscreen)
       ad-do-it
       (delete-other-windows))
     (defun magit-quit-session ()
       "Restores the previous window configuration and kills the magit buffer"
       (interactive)
       (kill-buffer)
       (jump-to-register :magit-fullscreen)))
 #+end_src

** Prescient

#+begin_src emacs-lisp
  (use-package prescient
    :custom
    (prescient-persist-mode 1)
    (prescient-history-length 1000)
    (prescient-aggressive-file-save t))
#+end_src
** Minibuffer

#+begin_src emacs-lisp
  (use-package minibuffer
    :straight nil
    :custom
    (completion-styles '(fuzzy
			       basic
			       partial-completion
			       substring
			       initials
			       emacs22)))
#+end_src

After having used Ido and Helm, I have settled on using Ivy (and Counsel / Swiper) as my completion mechanism. Sounds fancy. Anyway, it's not a huge package, but I've tinkered it into some neat things.

1. I have some settings for counsel-projectile in the projects section so I make sure that I'm always switching projects using counsel/ivy.

2. Return completes the current directory and shows the candidates that are inside (or whatever hierarchical equivalent there is), kind of like ido.

3. The C-j command selects whatever I've typed as the exact completion candidate. This is useful if I want to create a new file that is being matched to something that already exists.

4. Also, I wanted to make ~M-y~ display the counsel-version of yank, but then also cycle through options, just like the normal one does. Borrowed from [[http://pragmaticemacs.com/emacs/counsel-yank-pop-with-a-tweak/][Pragmatic Emacs]].

#+begin_src emacs-lisp
  (use-package counsel
    :config
    (counsel-mode 1)
    :bind
    ("C-x C-r" . counsel-recentf)
    ("C-x C-f" . counsel-find-file)
    ("M-x"     . counsel-M-x)
    ("s-x"     . counsel-M-x)
    ("C-x l"   . counsel-locate)
    ("C-h f"   . counsel-describe-function)
    ("C-h v"   . counsel-describe-variable)
    ("C-h k"   . counsel-descbinds)
    ("M-y"     . counsel-yank-pop))
#+end_src


#+begin_src emacs-lisp
  (use-package ivy
    :config
    (ivy-mode 1)
    (define-key ivy-minibuffer-map (kbd "C-j") #'ivy-immediate-done)
    (define-key ivy-minibuffer-map (kbd "RET") #'ivy-alt-done)
    (define-key ivy-minibuffer-map (kbd "M-y") #'ivy-next-line)
    :custom
    (ivy-use-ignore-default 'always)
    (ivy-ignore-buffers '("*elfeed-log*"))
    (ivy-use-virtual-buffers nil)
    (ivy-count-format "(%d/%d) ")
    (ivy-extra-directories nil)
    :bind
    ("C-x b" . ivy-switch-buffer))
#+end_src

#+begin_src emacs-lisp
  (use-package swiper
    :bind ("C-s" . swiper))
#+end_src

#+begin_src emacs-lisp
  (use-package ivy-posframe
    :disabled t
    :after ivy
    :if (display-graphic-p)
    :config
    (ivy-posframe-mode 1)
    :custom
    (ivy-posframe-display-functions-alist
     '((swiper                   . nil)
       (counsel-M-x              . ivy-posframe-display-at-frame-top-center)
       (ivy-completion-in-region . ivy-posframe-display-at-point)
       (t                        . ivy-posframe-display-at-frame-top-center))))
#+end_src

#+begin_src emacs-lisp
  (use-package ivy-prescient
    :after (ivy prescient)
    :config
    (ivy-prescient-mode 1))
 #+end_src

* Programming Modules
** Syntax Highlighting
#+begin_src emacs-lisp
  (use-package fish-mode)
  (use-package gitconfig-mode)
  (use-package gitignore-mode)
  (use-package lua-mode)
  (use-package toml-mode)
#+end_src
